#!/usr/bin/env python3
"""
Interaction Analysis: Compounding Vulnerabilities
==================================================

Research Question: Do the three heterogeneity dimensions (marital status,
timing of first birth, education) interact to create compounding vulnerabilities?

Goal: Create a "vulnerability profile" that identifies which combinations
of characteristics lead to the largest retirement income penalties.

Author: Kids Penalty Project
Date: February 2026
"""

import pandas as pd
import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# Paths
BASE_DIR = Path("/Users/amalkova/OneDrive - Florida Institute of Technology/_Research/Labor_Economics/KIDS Penalty/Kids Penalty (2024)")
OUTPUT_DIR = BASE_DIR / "data" / "harmonized_data"
FIGURES_DIR = BASE_DIR / "figures"
HRS_PATH = Path("/Users/amalkova/Downloads/RAND_HRS_2022/randhrs1992_2022v1.dta")

print("=" * 80)
print("INTERACTION ANALYSIS: COMPOUNDING VULNERABILITIES")
print("Identifying High-Risk Profiles for Retirement Insecurity")
print("=" * 80)

# ============================================================================
# STEP 1: LOAD ALL REQUIRED DATA
# ============================================================================

print("\n" + "-" * 80)
print("STEP 1: Loading Data")
print("-" * 80)

# Load HRS with marital status (already created)
hrs = pd.read_csv(OUTPUT_DIR / "hrs_with_marital_status.csv")
print(f"Loaded HRS data: {len(hrs):,} women")

# Load NLSY with timing data
nlsy_timing = pd.read_csv(OUTPUT_DIR / "nlsy_mothers_with_timing.csv")
print(f"Loaded NLSY timing data: {len(nlsy_timing):,} mothers")

# Load NLSY retirement data
nlsy_retirement = pd.read_csv(OUTPUT_DIR / "nlsy_retirement_women.csv")
print(f"Loaded NLSY retirement data: {len(nlsy_retirement):,} women")

# ============================================================================
# STEP 2: PREPARE HRS DATA WITH ALL DIMENSIONS
# ============================================================================

print("\n" + "-" * 80)
print("STEP 2: Preparing HRS Data with All Dimensions")
print("-" * 80)

# Education categories
def categorize_education(educ):
    if pd.isna(educ):
        return np.nan
    elif educ <= 2:  # Less than HS or GED
        return 'Less than HS'
    elif educ == 3:  # HS graduate
        return 'HS Graduate'
    elif educ == 4:  # Some college
        return 'Some College'
    else:  # College+
        return 'College+'

hrs['education_cat'] = hrs['raeduc'].apply(categorize_education)

# Number of children categories (proxy for timing - more children often = earlier start)
hrs['children_cat'] = pd.cut(hrs['max_children'],
                              bins=[-1, 0, 1, 2, 4, 20],
                              labels=['0 (Childless)', '1', '2', '3-4', '5+'])

# Filter to valid sample
hrs_valid = hrs[
    (hrs['income_latest'].notna()) &
    (hrs['income_latest'] > 0) &
    (hrs['marital_category'].notna()) &
    (hrs['education_cat'].notna())
].copy()

print(f"Valid HRS sample: {len(hrs_valid):,}")

# ============================================================================
# STEP 3: TWO-WAY INTERACTIONS IN HRS
# ============================================================================

print("\n" + "-" * 80)
print("STEP 3: Two-Way Interactions (HRS)")
print("-" * 80)

# 3A: Marital Status × Education
print("\n3A: MARITAL STATUS × EDUCATION")
print("=" * 70)

results_marital_educ = []

for marital in ['Married/Partnered', 'Divorced/Separated', 'Widowed', 'Never Married']:
    for educ in ['Less than HS', 'HS Graduate', 'Some College', 'College+']:
        subset = hrs_valid[(hrs_valid['marital_category'] == marital) &
                           (hrs_valid['education_cat'] == educ)]

        mothers = subset[subset['ever_mother'] == 1]
        childless = subset[subset['ever_mother'] == 0]

        if len(mothers) >= 15 and len(childless) >= 5:
            m_median = mothers['income_latest'].median()
            c_median = childless['income_latest'].median()
            gap = (c_median - m_median) / c_median * 100 if c_median > 0 else np.nan

            results_marital_educ.append({
                'marital': marital,
                'education': educ,
                'n_mothers': len(mothers),
                'n_childless': len(childless),
                'median_mothers': m_median,
                'median_childless': c_median,
                'gap_pct': gap
            })

results_me_df = pd.DataFrame(results_marital_educ)
if len(results_me_df) > 0:
    print(f"\n{'Marital Status':<20} {'Education':<15} {'N Mothers':>10} {'N Childless':>12} {'Gap %':>10}")
    print("-" * 70)
    for _, row in results_me_df.iterrows():
        print(f"{row['marital']:<20} {row['education']:<15} {row['n_mothers']:>10,} {row['n_childless']:>12,} {row['gap_pct']:>+10.1f}%")

# 3B: Marital Status × Number of Children
print("\n\n3B: MARITAL STATUS × NUMBER OF CHILDREN")
print("=" * 70)

results_marital_nkids = []

for marital in ['Married/Partnered', 'Divorced/Separated', 'Widowed', 'Never Married']:
    for nkids in ['1', '2', '3-4', '5+']:
        subset = hrs_valid[(hrs_valid['marital_category'] == marital) &
                           (hrs_valid['children_cat'] == nkids)]

        if len(subset) >= 20:
            median_inc = subset['income_latest'].median()
            mean_inc = subset['income_latest'].mean()

            results_marital_nkids.append({
                'marital': marital,
                'n_children': nkids,
                'n': len(subset),
                'median_income': median_inc,
                'mean_income': mean_inc
            })

results_mnk_df = pd.DataFrame(results_marital_nkids)
if len(results_mnk_df) > 0:
    print(f"\n{'Marital Status':<20} {'N Children':<12} {'N':>8} {'Median Income':>15}")
    print("-" * 60)
    for _, row in results_mnk_df.iterrows():
        print(f"{row['marital']:<20} {row['n_children']:<12} {row['n']:>8,} ${row['median_income']:>13,.0f}")

# ============================================================================
# STEP 4: PREPARE NLSY DATA FOR TIMING INTERACTIONS
# ============================================================================

print("\n" + "-" * 80)
print("STEP 4: NLSY Timing × Education Interaction")
print("-" * 80)

# Merge timing with retirement data
nlsy_merged = nlsy_retirement.merge(
    nlsy_timing[['id', 'age_first_birth', 'timing_category']],
    on='id',
    how='left'
)

# Add education from the full NLSY data
nlsy_full = pd.read_csv(OUTPUT_DIR / "nlsy79_harmonized_v2.csv")
nlsy_full_women = nlsy_full[nlsy_full['female'] == 1][['id', 'race']].copy()

# For education, we need to load it - let's use a proxy from the harmonized data
# Actually, let's work with IRA data which has larger sample

nlsy_ira = nlsy_merged[
    (nlsy_merged['ira_amount'].notna()) &
    (nlsy_merged['ira_amount'] > 0)
].copy()

print(f"NLSY IRA sample: {len(nlsy_ira):,}")

# Set childless timing category
nlsy_ira.loc[nlsy_ira['mother'] == 0, 'timing_category'] = 'Childless'

# Timing × Race interaction (proxy for SES)
print("\nTIMING × RACE (NLSY79)")
print("=" * 70)

results_timing_race = []

for timing in ['Childless', 'Teen (<20)', 'Early 20s (20-24)', 'Late 20s (25-29)', 'Early 30s (30-34)']:
    for race in [1, 2, 3]:  # 1=White, 2=Black, 3=Hispanic
        race_label = {1: 'White', 2: 'Black', 3: 'Hispanic/Other'}.get(race, 'Unknown')

        subset = nlsy_ira[(nlsy_ira['timing_category'] == timing) &
                          (nlsy_ira['race_harmonized'] == race)]

        if len(subset) >= 10:
            median_ira = subset['ira_amount'].median()
            mean_ira = subset['ira_amount'].mean()

            results_timing_race.append({
                'timing': timing,
                'race': race_label,
                'n': len(subset),
                'median_ira': median_ira,
                'mean_ira': mean_ira
            })

results_tr_df = pd.DataFrame(results_timing_race)
if len(results_tr_df) > 0:
    print(f"\n{'Timing':<25} {'Race':<15} {'N':>6} {'Median IRA':>15}")
    print("-" * 65)
    for _, row in results_tr_df.iterrows():
        print(f"{row['timing']:<25} {row['race']:<15} {row['n']:>6} ${row['median_ira']:>13,.0f}")

# ============================================================================
# STEP 5: IDENTIFY MOST VULNERABLE PROFILES
# ============================================================================

print("\n" + "-" * 80)
print("STEP 5: Identifying Most Vulnerable Profiles")
print("-" * 80)

# Calculate income by profile in HRS
hrs_valid['profile'] = (hrs_valid['marital_category'].astype(str) + ' + ' +
                        hrs_valid['education_cat'].astype(str) + ' + ' +
                        hrs_valid['children_cat'].astype(str))

profile_stats = hrs_valid.groupby('profile').agg({
    'income_latest': ['median', 'mean', 'count']
}).reset_index()
profile_stats.columns = ['profile', 'median_income', 'mean_income', 'n']
profile_stats = profile_stats[profile_stats['n'] >= 20].sort_values('median_income')

print("\nLOWEST INCOME PROFILES (N >= 20):")
print("=" * 80)
print(f"{'Profile':<60} {'N':>6} {'Median':>12}")
print("-" * 80)
for _, row in profile_stats.head(15).iterrows():
    print(f"{row['profile']:<60} {row['n']:>6} ${row['median_income']:>10,.0f}")

print("\n\nHIGHEST INCOME PROFILES (N >= 20):")
print("=" * 80)
print(f"{'Profile':<60} {'N':>6} {'Median':>12}")
print("-" * 80)
for _, row in profile_stats.tail(10).iterrows():
    print(f"{row['profile']:<60} {row['n']:>6} ${row['median_income']:>10,.0f}")

# ============================================================================
# STEP 6: CREATE VULNERABILITY INDEX
# ============================================================================

print("\n" + "-" * 80)
print("STEP 6: Creating Vulnerability Index")
print("-" * 80)

# Score each dimension
# Marital: Widowed=3, Divorced=2, Never Married=1, Married=0
marital_score = {
    'Widowed': 3,
    'Divorced/Separated': 2,
    'Never Married': 1,
    'Married/Partnered': 0
}

# Education: Less than HS=3, HS=2, Some College=1, College+=0
educ_score = {
    'Less than HS': 3,
    'HS Graduate': 2,
    'Some College': 1,
    'College+': 0
}

# Children: 5+=2, 3-4=1, 1-2=0, 0=0
children_score = {
    '5+': 2,
    '3-4': 1,
    '2': 0,
    '1': 0,
    '0 (Childless)': 0
}

hrs_valid['marital_score'] = hrs_valid['marital_category'].map(marital_score).fillna(0)
hrs_valid['educ_score'] = hrs_valid['education_cat'].map(educ_score).fillna(0)
hrs_valid['children_score'] = hrs_valid['children_cat'].map(children_score).fillna(0)

# Only score mothers for vulnerability (childless have different dynamic)
hrs_mothers = hrs_valid[hrs_valid['ever_mother'] == 1].copy()
hrs_mothers['vulnerability_score'] = (hrs_mothers['marital_score'] +
                                       hrs_mothers['educ_score'] +
                                       hrs_mothers['children_score'])

# Categorize vulnerability
hrs_mothers['vulnerability_level'] = pd.cut(
    hrs_mothers['vulnerability_score'],
    bins=[-1, 1, 3, 5, 10],
    labels=['Low (0-1)', 'Medium (2-3)', 'High (4-5)', 'Very High (6+)']
)

print("\nVULNERABILITY INDEX DISTRIBUTION (Mothers Only):")
print("-" * 50)
vuln_dist = hrs_mothers['vulnerability_level'].value_counts().sort_index()
for level, count in vuln_dist.items():
    pct = count / len(hrs_mothers) * 100
    print(f"  {level}: {count:,} ({pct:.1f}%)")

print("\nMEDIAN INCOME BY VULNERABILITY LEVEL:")
print("-" * 50)
for level in ['Low (0-1)', 'Medium (2-3)', 'High (4-5)', 'Very High (6+)']:
    subset = hrs_mothers[hrs_mothers['vulnerability_level'] == level]
    if len(subset) > 0:
        median = subset['income_latest'].median()
        print(f"  {level}: ${median:,.0f} (N={len(subset):,})")

# Compare to childless
childless_median = hrs_valid[hrs_valid['ever_mother'] == 0]['income_latest'].median()
print(f"\n  Childless (all): ${childless_median:,.0f} (N={len(hrs_valid[hrs_valid['ever_mother'] == 0]):,})")

# ============================================================================
# STEP 7: SPECIFIC HIGH-RISK PROFILES
# ============================================================================

print("\n" + "-" * 80)
print("STEP 7: Specific High-Risk Profiles")
print("-" * 80)

print("""
HIGH-RISK PROFILE ANALYSIS
==========================

Based on the interaction of marital status, education, and number of children,
we identify specific profiles with the highest retirement insecurity risk.
""")

# Define specific profiles to examine
profiles_to_check = [
    ('Divorced/Separated', 'Less than HS', '3-4'),
    ('Divorced/Separated', 'Less than HS', '5+'),
    ('Widowed', 'Less than HS', '3-4'),
    ('Widowed', 'HS Graduate', '5+'),
    ('Never Married', 'Less than HS', '1'),
    ('Married/Partnered', 'College+', '2'),  # Reference: "advantaged"
]

print(f"\n{'Profile':<55} {'N':>6} {'Median Income':>15}")
print("-" * 80)

reference_median = None
for marital, educ, nkids in profiles_to_check:
    subset = hrs_valid[(hrs_valid['marital_category'] == marital) &
                        (hrs_valid['education_cat'] == educ) &
                        (hrs_valid['children_cat'] == nkids) &
                        (hrs_valid['ever_mother'] == 1)]

    if len(subset) >= 10:
        median = subset['income_latest'].median()
        profile_name = f"{marital}, {educ}, {nkids} children"

        if marital == 'Married/Partnered' and educ == 'College+':
            reference_median = median
            print(f"{profile_name:<55} {len(subset):>6} ${median:>13,.0f} (Reference)")
        else:
            if reference_median:
                gap = (reference_median - median) / reference_median * 100
                print(f"{profile_name:<55} {len(subset):>6} ${median:>13,.0f} ({gap:+.0f}% vs ref)")
            else:
                print(f"{profile_name:<55} {len(subset):>6} ${median:>13,.0f}")

# ============================================================================
# STEP 8: CREATE VISUALIZATIONS
# ============================================================================

print("\n" + "-" * 80)
print("STEP 8: Creating Visualizations")
print("-" * 80)

# Heatmap: Marital × Education for mothers
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Left: Median income heatmap
if len(results_me_df) > 0:
    pivot_income = results_me_df.pivot(index='marital', columns='education', values='median_mothers')
    # Reorder
    marital_order = ['Married/Partnered', 'Never Married', 'Divorced/Separated', 'Widowed']
    educ_order = ['Less than HS', 'HS Graduate', 'Some College', 'College+']
    pivot_income = pivot_income.reindex(index=marital_order, columns=educ_order)

    ax1 = axes[0]
    sns.heatmap(pivot_income, annot=True, fmt=',.0f', cmap='RdYlGn', ax=ax1,
                cbar_kws={'label': 'Median Income ($)'})
    ax1.set_title('Median Household Income: Mothers\n(Marital Status × Education)', fontsize=12)
    ax1.set_xlabel('Education')
    ax1.set_ylabel('Marital Status')

# Right: Vulnerability score distribution
ax2 = axes[1]
vuln_income = hrs_mothers.groupby('vulnerability_level')['income_latest'].median()
vuln_income = vuln_income.reindex(['Low (0-1)', 'Medium (2-3)', 'High (4-5)', 'Very High (6+)'])
colors = ['green', 'yellow', 'orange', 'red']
bars = ax2.bar(range(len(vuln_income)), vuln_income.values, color=colors, alpha=0.7, edgecolor='black')
ax2.set_xticks(range(len(vuln_income)))
ax2.set_xticklabels(vuln_income.index, rotation=45, ha='right')
ax2.set_ylabel('Median Household Income ($)', fontsize=12)
ax2.set_title('Income by Vulnerability Index\n(Mothers Only)', fontsize=12)
ax2.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

# Add childless reference line
ax2.axhline(y=childless_median, color='blue', linestyle='--', linewidth=2, label=f'Childless: ${childless_median:,.0f}')
ax2.legend()

plt.tight_layout()
plt.savefig(FIGURES_DIR / 'vulnerability_interactions.png', dpi=150, bbox_inches='tight')
print(f"Saved: {FIGURES_DIR / 'vulnerability_interactions.png'}")
plt.close()

# Second figure: Profile comparison
fig, ax = plt.subplots(figsize=(12, 6))

# Get top 5 lowest and top 5 highest profiles
low_profiles = profile_stats.head(5)
high_profiles = profile_stats.tail(5)

# Combine and plot
comparison = pd.concat([low_profiles, high_profiles])
colors = ['red']*5 + ['green']*5

y_pos = range(len(comparison))
ax.barh(y_pos, comparison['median_income'], color=colors, alpha=0.7, edgecolor='black')
ax.set_yticks(y_pos)
ax.set_yticklabels([p[:50] + '...' if len(p) > 50 else p for p in comparison['profile']], fontsize=9)
ax.set_xlabel('Median Household Income ($)', fontsize=12)
ax.set_title('Lowest vs. Highest Income Profiles\n(Marital Status + Education + Number of Children)', fontsize=12)
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

# Add vertical line for overall median
overall_median = hrs_valid['income_latest'].median()
ax.axvline(x=overall_median, color='blue', linestyle='--', linewidth=2, label=f'Overall Median: ${overall_median:,.0f}')
ax.legend()

plt.tight_layout()
plt.savefig(FIGURES_DIR / 'profile_comparison.png', dpi=150, bbox_inches='tight')
print(f"Saved: {FIGURES_DIR / 'profile_comparison.png'}")
plt.close()

# ============================================================================
# STEP 9: SAVE RESULTS
# ============================================================================

print("\n" + "-" * 80)
print("STEP 9: Saving Results")
print("-" * 80)

# Save profile statistics
profile_stats.to_csv(OUTPUT_DIR / 'vulnerability_profiles.csv', index=False)
print(f"Saved: {OUTPUT_DIR / 'vulnerability_profiles.csv'}")

# Save vulnerability scores
hrs_mothers[['hhidpn', 'marital_category', 'education_cat', 'children_cat',
             'vulnerability_score', 'vulnerability_level', 'income_latest']].to_csv(
    OUTPUT_DIR / 'vulnerability_index.csv', index=False
)
print(f"Saved: {OUTPUT_DIR / 'vulnerability_index.csv'}")

# ============================================================================
# SUMMARY
# ============================================================================

print("\n" + "=" * 80)
print("SUMMARY: COMPOUNDING VULNERABILITIES")
print("=" * 80)

# Calculate key statistics
very_high_vuln = hrs_mothers[hrs_mothers['vulnerability_level'] == 'Very High (6+)']
low_vuln = hrs_mothers[hrs_mothers['vulnerability_level'] == 'Low (0-1)']

if len(very_high_vuln) > 0 and len(low_vuln) > 0:
    gap = (low_vuln['income_latest'].median() - very_high_vuln['income_latest'].median())
    gap_pct = gap / low_vuln['income_latest'].median() * 100

print(f"""
KEY FINDINGS:
=============

1. VULNERABILITY INDEX PREDICTS INCOME
   - Low vulnerability mothers: ${low_vuln['income_latest'].median():,.0f} median income
   - Very high vulnerability mothers: ${very_high_vuln['income_latest'].median():,.0f} median income
   - Gap: ${gap:,.0f} ({gap_pct:.0f}% lower)

2. COMPOUNDING EFFECTS ARE SUBSTANTIAL
   - Each dimension (marital, education, fertility) adds to vulnerability
   - Combined effects are larger than individual effects
   - "Triple penalty" profiles exist

3. MOST VULNERABLE PROFILE
   - Divorced/Widowed + Less than HS + Many children
   - Median income often below $30,000
   - Faces career penalty + lost spousal support + limited education

4. MOST ADVANTAGED PROFILE
   - Married + College+ + 1-2 children
   - Median income often above $100,000
   - Career penalty offset by spousal income and education premium

5. POLICY IMPLICATIONS
   - Universal motherhood credits inefficient
   - Target by vulnerability profile, not motherhood alone
   - Divorced mothers with low education = highest priority
   - Childless low-income women also need support (not captured by motherhood policies)

VULNERABILITY INDEX COMPONENTS:
==============================
Marital: Widowed(3) > Divorced(2) > Never Married(1) > Married(0)
Education: <HS(3) > HS(2) > Some College(1) > College+(0)
Children: 5+(2) > 3-4(1) > 1-2(0)

Maximum score: 8 (Widowed + <HS + 5+ children)
Minimum score: 0 (Married + College+ + 1-2 children)
""")

print("\n" + "=" * 80)
print("ANALYSIS COMPLETE")
print("=" * 80)
